# VictoriaMetrics OAuth Gateway Configuration
# Redis State Storage Example

server:
  address: ":8080"
  timeouts:
    readTimeout: 30s
    writeTimeout: 30s
    idleTimeout: 120s

# Multiple upstream configuration with Redis state storage
upstream:
  multiple:
    enabled: true
    
    # Backend configuration - distributed across multiple instances
    backends:
      - url: "http://vm-cluster-1:8428"
        weight: 3
      - url: "http://vm-cluster-2:8428" 
        weight: 2
      - url: "http://vm-cluster-3:8428"
        weight: 1
        
    # Load balancing strategy
    loadBalancing:
      strategy: "weighted-round-robin"
      
    # Health checking configuration
    healthCheck:
      checkInterval: 30s
      timeout: 10s
      healthyThreshold: 2
      unhealthyThreshold: 3
      healthEndpoint: "/health"
      
    # Request queuing for high availability
    queue:
      enabled: true
      maxSize: 1000
      timeout: 5s
      
    # Request handling
    timeout: 30s
    maxRetries: 3
    retryBackoff: 100ms

# Distributed state storage using Redis
stateStorage:
  type: "redis"
  redis:
    address: "redis:6379"
    password: ""  # Set if Redis requires authentication
    database: 0   # Redis database number
    keyPrefix: "vm-proxy-auth:"
    
    # Connection settings
    connectTimeout: 5s
    readTimeout: 3s
    writeTimeout: 3s
    
    # Connection pooling for high performance
    poolSize: 20
    minIdleConns: 5
    
    # Retry configuration for resilience
    maxRetries: 3
    minRetryBackoff: 100ms
    maxRetryBackoff: 1s

# Authentication configuration
auth:
  jwt:
    # JWKS for production (recommended)
    jwks:
      url: "https://your-auth-provider.com/.well-known/jwks.json"
      cacheTTL: 1h
    
    # JWT validation settings
    algorithm: "RS256"
    issuer: "your-auth-provider"
    audience: "vm-proxy-auth"
    leeway: 30s

# Tenant mapping configuration
tenantMapping:
  - jwtClaim: "team_id"
    staticMapping:
      team-alpha: "1000"
      team-beta: "1001"
      team-gamma: "1002"

# Advanced tenant filtering
tenantFilter:
  strategy: "orConditions"
  labels:
    accountLabel: "vm_account_id"
    projectLabel: "vm_project_id"
    useProjectId: true

# Metrics and monitoring
metrics:
  enabled: true
  path: "/metrics"
  
  # Redis state storage adds these metrics:
  # - vm_proxy_auth_state_storage_operations_total{operation, result}
  # - vm_proxy_auth_state_storage_connection_pool{state}
  # - vm_proxy_auth_redis_pubsub_events_total{type}
  # - vm_proxy_auth_distributed_state_events_total{node_id, type}

# Logging configuration
logging:
  level: "info"
  format: "json"
  
  # Redis state storage structured logs include:
  # - redis_operation: get/set/delete/watch operations
  # - key_prefix: for watch operations
  # - node_id: source of distributed state events
  # - connection_info: Redis connection details

# Production deployment notes:
#
# 1. Redis High Availability:
#    - Use Redis Cluster or Redis Sentinel for production
#    - Configure appropriate failover timeouts
#    - Monitor Redis performance and memory usage
#
# 2. Multi-Instance Deployment:
#    - Each vm-proxy-auth instance gets unique node_id (auto-generated)
#    - Backend state is synchronized across all instances via Redis pub/sub
#    - Health check coordination prevents thundering herd effects
#
# 3. Security:
#    - Enable Redis AUTH if Redis is network-accessible
#    - Use TLS for Redis connections in production
#    - Configure appropriate Redis ACLs
#
# 4. Performance:
#    - Tune Redis connection pool size based on expected load
#    - Monitor Redis pub/sub channel performance
#    - Consider Redis memory optimization settings
#
# 5. Monitoring:
#    - Track Redis connection pool metrics
#    - Monitor distributed state event frequency
#    - Set up alerts for Redis connection failures